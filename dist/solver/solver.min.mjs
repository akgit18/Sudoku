function m(a,b){if(16>a)return Uint8Array;if(b("This Sudoku is likely too big to solve in a reasonable amount of time. Are you sure that you'd like to continue?")){if(256>a)return Uint16Array;if(65536>a)return Uint32Array;throw new RangeError(`This Sudoku (box size ${a}) is too big too solve!`);}throw Error("Sudoku solving stopped by user.");}const n=[,255,65535,,4294967295];function p(a,b,d,c){if(c)for(var f of c){if(!q(a,f[0],f[1],b,d))return!1}else for(c=0;c<b;c++)for(f=0;f<b;f++)if(!q(a,c,f,b,
d))return!1;return!0}function q(a,b,d,c,f){const e=a[b*c+d];if(e!==n[a.BYTES_PER_ELEMENT]){if(e>c)throw Error(`Value ${e} on row ${b+1}, column ${d+1} too large.`);for(const g of f)if(!g(a,b,d,c,e))return!1}return!0}function r(a,b){for(let d=0;d<b;d++)for(let c=0;c<b;c++)if(a[d*b+c]===n[a.BYTES_PER_ELEMENT])return[d,c]}function t(a,b,d,c,f){let e=0;if(f!==n[a.BYTES_PER_ELEMENT]){if(f>b)throw Error(`Value ${f} on row ${d+1}, column ${c+1} too large.`);for(const g of u(d,c,b))f==a[g]&&e++}return e}
function v(a,b,d,c){let f=1,e=Infinity;for(let g=1;g<=b;g++){let h=t(a,d,c,g,a[d*b+c]);h<e&&(e=h,f=g)}return f}const w=new Map;function u(a,b,d){w.has(d)||w.set(d,new Map);const c=a*d+b;var f=w.get(d)?.get(c);if(f)return f;var e=Math.sqrt(d);f=new Set;var g=Math.floor(a/e)*e;const h=Math.floor(b/e)*e;for(let k=0;k<e;++k)for(let l=0;l<e;++l)k+g==a&&l+h==b||f.add([k+g,l+h]);e=new Set;for(g=0;g<d;++g)g!=a&&e.add([g,b]),g!=b&&e.add([a,g]);a=new Set;for(const k of f)a.add(k[0]*d+k[1]);for(const k of e)a.add(k[0]*
d+k[1]);w.get(d)?.set(c,a);return a}function x(a,b,d,c,f){const e=b*c+d;for(let g=1;g<c+1;++g)if(a[e]=g,q(a,b,d,c,f)){const h=r(a,c);if(h){if(x(a,h[0],h[1],c,f))return!0}else return!0}a[e]=-1;return!1}function y(a,b,d,c,f){for(b=[];d=r(a,c);)a[d[0]*c+d[1]]=v(a,c,d[0],d[1]),b.push(d);d=1E3*c;for(let e=0;e<d;e++){let g=b[Math.floor(Math.random()*b.length)];const h=g[0]*c+g[1];t(a,c,g[0],g[1],a[h])&&(a[h]=v(a,c,g[0],g[1]));if(p(a,c,f,b))return!0}throw Error(`${d} iterations exceeded without finding a solution.`);
}const z=[[1,function(a,b,d,c,f){for(let e=0;e<c;++e){const g=b*c+e;if(f==a[e*c+d]&&e!=b||f==a[g]&&e!=d)return!1}return!0}],[2,function(a,b,d,c,f){const e=Math.sqrt(c),g=Math.floor(b/e)*e,h=Math.floor(d/e)*e;for(let k=0;k<e;++k)for(let l=0;l<e;++l)if((k+g!=b||l+h!=d)&&a[(k+g)*c+(l+h)]==f)return!1;return!0}],[4,function(a,b,d,c,f){const e=[-2,-2,-1,-1,1,1,2,2],g=[-1,1,-2,2,-2,2,-1,1];for(let h=0;8>h;h++){const k=b+e[h],l=d+g[h];if(0<=k&&k<c&&0<=l&&l<c&&f==a[k*c+l])return!1}return!0}],[8,function(a,
b,d,c,f){const e=[-1,-1,-1,0,0,1,1,1],g=[-1,0,1,-1,1,-1,0,1];for(let h=0;8>h;h++){const k=b+e[h],l=d+g[h];if(0<=k&&k<c&&0<=l&&l<c&&f==a[k*c+l])return!1}return!0}],[16,function(a,b,d,c,f){const e=[-1,0,0,1],g=[0,-1,1,0];for(let k=0;4>k;++k){var h=b+e[k];const l=d+g[k];if(0<=h&&h<c&&0<=l&&l<c&&(h=h*c+l,f+1==a[h]||f-1==a[h]))return!1}return!0}]];self instanceof WorkerGlobalScope&&(self.onmessage=a=>{try{const b=a.data;switch(b.type){case 1:A(b.data.g,b.data.h,b.data.rules,b.data.method);break;case 2:break;
default:B(new TypeError(`Unknown message type: ${JSON.stringify(b)}`))}}catch(b){B(b)}});function B(a){console.error(a);self.postMessage({type:-2,data:a})}function C(a,b,d){self.postMessage({type:-1,data:{g:a,i:b,j:d}},[a])}function A(a,b,d,c){a:switch(c){case "1":c=x;break a;case "2":c=y;break a;case "3":throw Error("DLX is not yet implemented.");default:throw Error(`${c} is not a supported solving method!`);}const f=D(d);d=b**2;a=new (m(b,()=>!0))(a,0,d**2);if(!p(a,d,f))throw Error("Inputted board not valid.");
const e=r(a,d);if(e)if(b=Date.now(),c=c(a,e[0],e[1],d,f),b=Date.now()-b,c)C(a.buffer,d,b);else throw Error("Unsolvable board.");else console.log("Board already legally filled. Doing nothing.")}function D(a){const b=[];for(const [d,c]of z)a&d&&b.push(c);return b}export{};//# sourceMappingURL=solver.min.mjs.map
