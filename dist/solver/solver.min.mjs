function m(a,d){if(16>a)return Uint8Array;if(d("This Sudoku is likely too big to solve in a reasonable amount of time. Are you sure that you'd like to continue?")){if(256>a)return Uint16Array;if(65536>a)return Uint32Array;throw new RangeError(`This Sudoku (box size ${a}) is too big too solve!`);}throw Error("Sudoku solving stopped by user.");}const n=[,255,65535,,4294967295];function p(a,d,c,b,f){const e=[-2,-2,-1,-1,1,1,2,2],g=[-1,1,-2,2,-2,2,-1,1];for(let k=0;8>k;k++){const h=d+e[k],l=c+g[k];if(0<=
h&&h<b&&0<=l&&l<b&&f==a[h*b+l])return!1}return!0}function q(a,d,c,b,f){const e=[-1,-1,-1,0,0,1,1,1],g=[-1,0,1,-1,1,-1,0,1];for(let k=0;8>k;k++){const h=d+e[k],l=c+g[k];if(0<=h&&h<b&&0<=l&&l<b&&f==a[h*b+l])return!1}return!0}function r(a,d,c,b,f){const e=[-1,0,0,1],g=[0,-1,1,0];for(let h=0;4>h;++h){var k=d+e[h];const l=c+g[h];if(0<=k&&k<b&&0<=l&&l<b&&(k=k*b+l,f+1==a[k]||f-1==a[k]))return!1}return!0}const t=[function(a,d,c,b,f){for(let e=0;e<b;++e){const g=d*b+e;if(f==a[e*b+c]&&e!=d||f==a[g]&&e!=c)return!1}return!0},
function(a,d,c,b,f){const e=Math.sqrt(b),g=Math.floor(d/e)*e,k=Math.floor(c/e)*e;for(let h=0;h<e;++h)for(let l=0;l<e;++l)if((h+g!=d||l+k!=c)&&a[(h+g)*b+(l+k)]==f)return!1;return!0}];function u(a,d,c){if(c)for(var b of c){if(!v(a,b[0],b[1],d))return!1}else for(c=0;c<d;c++)for(b=0;b<d;b++)if(!v(a,c,b,d))return!1;return!0}function v(a,d,c,b){const f=a[d*b+c];if(f!==n[a.BYTES_PER_ELEMENT]){if(f>b)throw Error(`Value ${f} on row ${d+1}, column ${c+1} too large.`);for(const e of t)if(!e(a,d,c,b,f))return!1}return!0}
function w(a,d){for(let c=0;c<d;c++)for(let b=0;b<d;b++)if(a[c*d+b]===n[a.BYTES_PER_ELEMENT])return[c,b]}function x(a,d,c,b,f){let e=0;if(f!==n[a.BYTES_PER_ELEMENT]){if(f>d)throw Error(`Value ${f} on row ${c+1}, column ${b+1} too large.`);for(const g of y(c,b,d))f==a[g]&&e++}return e}function z(a,d,c,b){let f=1,e=Infinity;for(let g=1;g<=d;g++){let k=x(a,c,b,g,a[c*d+b]);k<e&&(e=k,f=g)}return f}const A=new Map;function y(a,d,c){A.has(c)||A.set(c,new Map);const b=a*c+d;var f=A.get(c)?.get(b);if(f)return f;
var e=Math.sqrt(c);f=new Set;var g=Math.floor(a/e)*e;const k=Math.floor(d/e)*e;for(let h=0;h<e;++h)for(let l=0;l<e;++l)h+g==a&&l+k==d||f.add([h+g,l+k]);e=new Set;for(g=0;g<c;++g)g!=a&&e.add([g,d]),g!=d&&e.add([a,g]);a=new Set;for(const h of f)a.add(h[0]*c+h[1]);for(const h of e)a.add(h[0]*c+h[1]);A.get(c)?.set(b,a);return a}function B(a,d,c,b){const f=d*b+c;for(let e=1;e<b+1;++e)if(a[f]=e,v(a,d,c,b)){const g=w(a,b);if(g){if(B(a,g[0],g[1],b))return!0}else return!0}a[f]=-1;return!1}function C(a,d,c,
b){for(d=[];c=w(a,b);)a[c[0]*b+c[1]]=z(a,b,c[0],c[1]),d.push(c);c=1E3*b;for(let f=0;f<c;f++){let e=d[Math.floor(Math.random()*d.length)];const g=e[0]*b+e[1];x(a,b,e[0],e[1],a[g])&&(a[g]=z(a,b,e[0],e[1]));if(u(a,b,d))return!0}throw Error(`${c} iterations exceeded without finding a solution.`);}self instanceof WorkerGlobalScope&&(self.onmessage=a=>{try{const b=a.data;switch(b.type){case 1:var d=b.data;switch(d){case "1":case "backtracking":D=B;break;case "2":case "localSearch":D=C;break;case "3":case "DLX":break;
default:throw Error(`${d} is not a supported solving method!`);}break;case 2:a:switch(b.data){case "1":var c=p;break a;case "2":c=q;break a;case "3":c=r;break a;default:throw Error("Attempting to toggle unknown rule");}a=c;const f=t.indexOf(a);-1===f?t.push(a):t.splice(f,1);break;case 3:E(b.data.g,b.data.h);break;case 4:break;default:F(new TypeError(`Unknown message type: ${JSON.stringify(b)}`))}}catch(b){F(b)}});function F(a){console.error(a);self.postMessage({type:-2,data:a})}function G(a,d,c){self.postMessage({type:-1,
data:{g:a,i:d,j:c}},[a])}let D=(a,d,c,b)=>B(a,d,c,b);function E(a,d){const c=d**2;a=new (m(d,()=>!0))(a,0,c**2);if(!u(a,c))throw Error("Inputted board not valid.");var b=w(a,c);if(b)if(d=Date.now(),b=D(a,b[0],b[1],c),d=Date.now()-d,b)G(a.buffer,c,d);else throw Error("Unsolvable board.");else console.log("Board already legally filled. Doing nothing.")}export{};
